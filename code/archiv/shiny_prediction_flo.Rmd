---
title: "Shiny_directed_graph"
output: html_document
date: "2023-03-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load the Required Libraries---------------------------------------------------
library(shiny)
library(dplyr)
library(ggplot2)
library(igraph)
library(visNetwork)
```

```{r}
#Load the Data
df.football.transfer <- read.csv(file = '../data/football-transfers.csv')
data <- df.football.transfer
```

```{r}
# User Interface
ui <- fluidPage(
  titlePanel("Football Transfers Predictions (Based on Season 2017-2021)"),
  
  sidebarLayout(
    sidebarPanel(
      h4("Choose a country, club, position and number of players to show"),
      selectInput("country", "Country:", unique(data$country)),
      uiOutput("club_ui"),
      selectInput("position", "Position:", c("All", "Goalkeeper", "Defence", "Midfield", "Attack")),
      selectInput("num_rows", "Number of players to display:", choices = c(10, 20, 30, 50))
    ),
    
    mainPanel(
      h4("Next Possible Transfers"),
      visNetworkOutput("prediction_graph", width = "70%", height = "500px"),
      uiOutput("table_title"),
      tableOutput("player_table")
    )
  )
)

# Server function
server <- function(input, output) {
  season_data <- reactive({
    data %>% filter(season >= 2017 & season <= 2021)
    })

  
  output$club_ui <- renderUI({
    clubs_filtered <- season_data() %>% filter(country == input$country) %>% select(club)
    selectInput("club", "Club:", choices = unique(clubs_filtered))
  })
  
  df_top_5_pred_dealing_clubs <- reactiveVal()
  selected_club <- reactiveVal()
  
  output$prediction_graph <- renderVisNetwork({
    req(input$club)
    
    season_filtered <- season_data() %>% 
      select(c("dealing_club", "club", "name"))

    # Create directed graph ----------------------------------------------------
    g.season_filtered <- graph_from_data_frame(season_filtered[,
                                                                c("dealing_club", 
                                                                  "club")], 
                                                directed = TRUE)

    # Get predicted edges ----------------------------------------------------------
    m.predicted.edges <- as.matrix(cocitation(g.season_filtered) * 
                                 (1 - get.adjacency(g.season_filtered)))

    df.predicted.edges <- as.data.frame(which(m.predicted.edges > 0, 
                                           arr.ind = TRUE))

    colnames(df.predicted.edges) <- c("dealing_club", "club")

    df.predicted.edges$transfer_weight <- m.predicted.edges[m.predicted.edges > 0]

    df.predicted.edges$dealing_club <- 
      rownames(m.predicted.edges)[df.predicted.edges$dealing_club]

    df.predicted.edges$club <- 
      rownames(m.predicted.edges)[df.predicted.edges$club]

    # Remove self-loops where dealing club and club are the same ---------------
    df.predicted.edges <- subset(df.predicted.edges, dealing_club != club)

    # Normalize the transfer_weight column -------------------------------------
    max.transfer.weight <- max(df.predicted.edges$transfer_weight)

    df.predicted.edges$transfer_prob <- round(df.predicted.edges$transfer_weight / 
                                                max.transfer.weight, 2)

    # Filter edges to only include those with selected club as target --------------
    df.predicted.edges <- df.predicted.edges[df.predicted.edges$club == 
                                               input$club, ]
    df.predicted.edges <- df.predicted.edges[df.predicted.edges$dealing_club != 
                                               input$club, ]

    # Keep only the relevant columns -----------------------------------------------
    df.predicted.edges <- subset(df.predicted.edges,
                                 select=c("dealing_club", "club", "transfer_prob"))

    # Remove the index column by setting row.names to NULL -------------------------
    row.names(df.predicted.edges) <- NULL
    
        # Sort edges by transfer probability -------------------------------------------
    df.predicted.edges <- df.predicted.edges[order(df.predicted.edges$transfer_prob, 
                                                   decreasing = TRUE), ]
    df.top.5.pred.dealing.clubs <- df.predicted.edges[1:5, ]
    df_top_5_pred_dealing_clubs(df.top.5.pred.dealing.clubs)
    rownames(df.top.5.pred.dealing.clubs) <- NULL

    # Create directed graph from df.top.5.pred.dealing.clubs
    g.test <- graph_from_data_frame(df.top.5.pred.dealing.clubs[, c("dealing_club", "club", "transfer_prob")],
                                    directed = TRUE)
    
    # Set edge weights to transfer_probability
    E(g.test)$weight <- df.top.5.pred.dealing.clubs$transfer_prob
    
    # Set vertex colors for chosen club and dealing clubs
    V(g.test)$color <- ifelse(V(g.test)$name == input$club, "red", "blue")
    
    # Create nodes data frame
    nodes <- data.frame(id = V(g.test)$name, 
                        label = V(g.test)$name, 
                        color = V(g.test)$color)

    # Add the transfer_prob as the label for the edges
    edges <- data.frame(from = get.edgelist(g.test)[, 1],
                        to = get.edgelist(g.test)[, 2],
                        label = paste(round(E(g.test)$weight, digits = 2)),
                        value = E(g.test)$weight)
    
    # Create color gradient
    edge.color.gradient <- colorRampPalette(c("yellow", "orange", "red"))
    
    # Determine number of unique edge weights
    num.unique.weights <- length(unique(E(g.test)$weight))
    
    # Generate color vector based on edge weights
    edge.colors <- edge.color.gradient(num.unique.weights)
    
    # Add 'color' column to the edges data frame
    edges$color <- edge.colors[as.numeric(cut(E(g.test)$weight, breaks = num.unique.weights))]

    # Create visNetwork graph
    visNetwork(nodes, edges) %>%
      visEdges(smooth = TRUE,
               width = 1,
               label = paste(round(E(g.test)$weight, digits = 2)), 
               arrows = list(to = list(enabled = TRUE)),
               color = list(color = edges$color),
               font = list(size = 26)) %>%
      visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
      visPhysics(solver = "barnesHut",
                 barnesHut = list(gravitationalConstant = -25000,
                                  centralGravity = 0.5)) %>%
      visInteraction(zoomView = FALSE,
                     dragView = FALSE)
  })
  
    table_title <- reactive({
    if (!is.null(selected_club()) && selected_club() %in% df_top_5_pred_dealing_clubs()$dealing_club) {
      paste("Top Players in", selected_club())
    } else {
      "Top Players in 5 Predicted Dealing Clubs"
    }
  })

  output$table_title <- renderUI({
    h4(table_title())
  })
  
    # Observe the selected club from the prediction_graph and update the selected_club reactive variable
    observeEvent(input$prediction_graph_selected, {
      selected_club(input$prediction_graph_selected)
      })

  output$player_table <- renderTable({
      
      top_5_clubs <- df_top_5_pred_dealing_clubs()$dealing_club
      player_data <- season_data() %>%
        filter(dealing_club %in% top_5_clubs) %>%
        filter(if (input$position != "All") position_category == input$position else TRUE) %>%
        select(name, age, position, nationality, normalized_performance, market_value, fee, dealing_club) %>%
        arrange(desc(normalized_performance))
  
      # Filter player data based on the selected club or show data for all top 5 clubs
      if (!is.null(selected_club()) && selected_club() %in% top_5_clubs) {
        player_data <- player_data %>% filter(dealing_club == selected_club())
      }
      

      # Rename columns
      player_data <- player_data %>%
        rename(
          "Player Name" = name,
          "Age" = age,
          "Position" = position,
          "Nationality" = nationality,
          "Performance" = normalized_performance,
          "Market Value" = market_value,
          "Transfer Fee" = fee,
          "Dealing Club" = dealing_club
        )
      
      # Remove decimals from market_value and fee columns
      player_data$Market_Value <- format(player_data$Market_Value, nsmall = 0, scientific = FALSE)
      player_data$Transfer_Fee <- format(player_data$Transfer_Fee, nsmall = 0, scientific = FALSE)
      
      # Display the selected number of rows
      player_data <- head(player_data, n = input$num_rows)
    
      player_data
    })
}

# Run the Shiny app
shinyApp(ui = ui, server = server)
```

```{r}
# test zooming with visNetwork is working first try without direction and player
# ui
ui <- fluidPage(
  titlePanel("Football Transfers Prediction"),
  
  sidebarLayout(
    sidebarPanel(
      h4("Choose a country, club, duration"),
            sliderInput("year", "Select year range:",
                  min = min(data$season),
                  max = max(data$season),
                  value = c(min(data$season), max(data$season)),
                  step = 1,sep = ""),
      selectInput("country", "Country:", unique(data$country)),
      uiOutput("club_ui")
    ),
    
    mainPanel(
      h4("Next possible transfers"),
      #verbatimTextOutput("player_count"),
      plotOutput("prediction_graph") # Change this line
    )
  )
)

#Create the Server Function

server <- function(input, output) {
  
  season_data <- reactive({
    data %>% filter(season >= input$year[1] & season <= input$year[2])
  })
  
  output$club_ui <- renderUI({
    clubs_filtered <- season_data() %>% filter(country == input$country) %>% select(club)
    selectInput("club", "Club:", choices = unique(clubs_filtered))
  })
  
  #test
  df.performers <- reactive({
    season_filtered <- season_data() %>% filter(country == input$country, club == input$club)
    
    # Filter for top performers based on age and performance score, and keep only top 20
    performers_top <- season_filtered[order(-season_filtered$normalized_performance), ][1:7, ]
    
    # Create a new dataframe with only the relevant columns
    performers_df <- subset(performers_top, select=c("dealing_club", "club", "name"))
    
    # Create the graph
    g.perform <- graph_from_data_frame(performers_df, directed = TRUE)
    
    # Convert graph to edges and nodes data frames
    nodes_df <- data.frame(id = V(g.perform)$name, label = V(g.perform)$name)
    edges_df <- data.frame(from = get.edgelist(g.perform)[, 1], to = get.edgelist(g.perform)[, 2])
    
    # Create a visNetwork object instead of using the base igraph plot
    visNetwork(nodes_df, edges_df, width = "100%", height = "600px") %>%
      visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
      visLayout(randomSeed = 42)
  })
  
  output$performers_graph <- renderVisNetwork({
    df.performers()
  })
}
```


```{r}
# fist try
# first try
#Create the User Interface
ui <- fluidPage(
  titlePanel("Football Transfers Descriptive Statistics"),
  
  sidebarLayout(
    sidebarPanel(
      h4("Choose a country, club, duration"),
            sliderInput("year", "Select year range:",
                  min = min(data$season),
                  max = max(data$season),
                  value = c(min(data$season), max(data$season)),
                  step = 1,sep = ""),
      selectInput("country", "Country:", unique(data$country)),
      uiOutput("club_ui")
    ),
    
    mainPanel(
      h4("Transfers to chosen club"),
      #verbatimTextOutput("player_count"),
      plotOutput("performers_graph")
    )
  )
)

#Create the Server Function

server <- function(input, output) {
  
  season_data <- reactive({
    data %>% filter(season >= input$year[1] & season <= input$year[2])
  })
  
  output$club_ui <- renderUI({
    clubs_filtered <- season_data() %>% filter(country == input$country) %>% select(club)
    selectInput("club", "Club:", choices = unique(clubs_filtered))
  })
  
  #test
  df.performers <- reactive({
    season_filtered <- season_data() %>% filter(country == input$country, club == input$club)
    
    # Filter for top performers based on age and performance score, and keep only top 20
    performers_top <- season_filtered[order(-season_filtered$normalized_performance), ][1:7, ]
    
    # Create a new dataframe with only the relevant columns
    performers_df <- subset(performers_top, select=c("dealing_club", "club", "name"))
    
    # Create the graph
    g.perform <- graph_from_data_frame(performers_df, directed = TRUE)
    
    # Convert graph to edges and nodes data frames
    nodes_df <- data.frame(id = V(g.perform)$name)
    edges_df <- data.frame(from = get.edgelist(g.perform)[, 1], to = get.edgelist(g.perform)[, 2])
    
    # Plot the graph
    plot(g.perform,
         edge.arrow.size=0.5,
         vertex.size=4,
         vertex.color="lightblue",
         vertex.label.color="black",
         vertex.label.cex=0.8,
         vertex.label.dist=1.8,
         edge.label = E(g.perform)$name,
        layout=layout_with_fr)
  })
  
  output$performers_graph <- renderPlot({
    df.performers()
  })

}

```

```{r}
#load the app 
shinyApp(ui, server)
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```