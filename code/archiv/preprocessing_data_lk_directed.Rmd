---
title: "preprocceing_data"
output: html_document
date: "2023-03-08"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:


```{r }
# Load librarys-----------------------------------------------------------------
library(igraph)
library(data.table)
library(ggplot2)
library(tibble)
```

```{r }
# Load data---------------------------------------------------------------------
df.football.transfer <- read.csv(file = '../data/football-transfers.csv')
dt.filtered.data <- data.table(df.football.transfer)

```

```{r }

# Create the performance column as described earlier
df.football.transfer$performance <- with(df.football.transfer, 
                                ifelse(fee == 0, market_value / (1 * age), 
                                       market_value / fee / age))

# compute the mean and standard deviation of the performance column
mean.performance <- mean(df.football.transfer$performance)
sd.performance <- sd(df.football.transfer$performance)

# create a normalized column
df.football.transfer$normalized_performance <- (
  df.football.transfer$performance - mean.performance) / sd.performance

# compute the min and max of the performance column
min.performance <- min(df.football.transfer$performance)
max.performance <- max(df.football.transfer$performance)

# create a normalized column
df.football.transfer$normalized_performance <- 
  (df.football.transfer$performance - min.performance) / (max.performance - 
                                                            min.performance)

# drop the original performance and normalized column column
df.football.transfer$performance <- NULL

df.football.transfer
```

```{r }
# Filter for top performers
 df.performers <- head(df.football.transfer[order(
   -df.football.transfer$normalized_performance), ], 50)

# Create a new dataframe with only the relevant columns
 df.remove.col <- subset(df.performers, select=c("season", "country","club",
                                                 "dealing_club", "name", "age",
                                                 "position", "nationality",
                                                 "normalized_performance"))
 
# reset the row names/index
rownames(df.remove.col) <- NULL

df.remove.col
```

```{r }

# Plot the best normalized_performance transfers of a favorite club

favorite <- "Eintracht Frankfurt"


# Filter for top performers based on age and performance score, and keep only top 20
df.performers <- df.football.transfer[df.football.transfer$club == favorite, ]
df.performers <- df.performers[order(-df.performers$normalized_performance), ][1:7, ]

# Create a new dataframe with only the relevant columns
df.performers <- subset(df.performers, select=c("dealing_club", "club", "name"))

# Create the graph
g.perform <- graph_from_data_frame(df.performers, directed = TRUE)

# Plot the graph
plot(g.perform,
     edge.arrow.size=0.5,
     vertex.size=4,
     vertex.color="lightblue",
     vertex.label.color="black",
     vertex.label.cex=0.8,
     vertex.label.dist=1.8,
     edge.label = E(g.perform)$name,
     layout=layout_with_fr)

```

```{r }
# Optional if you want to filter something

dt.filtered.data <- dt.filtered.data[season >= 2018 & season <= 2021]
df.football.transfer <- df.football.transfer %>% filter(season >= 2018 &
                                                          season <= 2021)

```

```{r }
# Plot different kind of graphs
```

```{r }

# Create directed graph with receiving club as the target node and sending club as the source node
g.directed <- graph_from_data_frame(
  df.football.transfer[, c("dealing_club", "club")], directed = TRUE)

# Plot the directed graph without labels, small nodes, and edges
plot(g.directed, vertex.size = 5, edge.arrow.size = 0.5, vertex.label.cex = 0,
     edge.color = "gray", vertex.label = NA, vertex.color = "lightblue")

# Set vertex colors
V(g.directed)$color <- ifelse(V(g.directed)$name %in% df.football.transfer$dealing_club, "red", "blue")

# Plot the directed graph with red nodes for dealing_club and blue nodes for club
plot(g.directed, vertex.size = 5, edge.arrow.size = 0.5, vertex.label.cex = 0,
     edge.color = "gray", vertex.label = NA, vertex.color = V(g.directed)$color)


# Extract the edge list
edges <- get.edgelist(g.directed, names = TRUE)

# Add a column with the edge names
#edges$edge_name <- paste(edges[,1], edges[,2], sep = " -> ")

# Print the edge list
head(edges)

summary(g.directed)

```
```{r }
# Same as above but with simplify and removed loops

# Create graph with just connected clubs
g <- induced.subgraph(g.directed, which(degree(g.directed) > 0))

# Remove loops from the graph --> Huge impact speak with flo
g <- simplify(g.directed, remove.loops = TRUE)

# Plot the directed graph without labels, small nodes, and edges
plot(g, vertex.size = 5, edge.arrow.size = 0.5, vertex.label.cex = 0,
     edge.color = "gray", vertex.label = NA, vertex.color = "lightblue")

# Set vertex colors
V(g)$color <- ifelse(V(g)$name %in% df.football.transfer$dealing_club, "red", "blue")

# Plot the directed graph with red nodes for dealing_club and blue nodes for club
plot(g, vertex.size = 5, edge.arrow.size = 0.5, vertex.label.cex = 0,
     edge.color = "gray", vertex.label = NA, vertex.color = V(g.directed)$color)


# Extract the edge list
edges <- get.edgelist(g, names = TRUE)

# Add a column with the edge names
#edges$edge_name <- paste(edges[,1], edges[,2], sep = " -> ")

# Print the edge list
head(edges)
summary(g)

```

```{r }

# Create weighted graph with normalized performance as the edge weight
g.weighted <- graph_from_data_frame(
  df.football.transfer[, c("dealing_club", "club",
                           "normalized_performance")], directed = TRUE)

# Set the edge weight attribute to the normalized performance column
E(g.weighted)$weight <- df.football.transfer$normalized_performance
E(g.weighted)$weight[E(g.weighted)$weight <= 0] <- NA


# Plot the weighted graph without labels, small nodes, and edges
plot(g.weighted, vertex.size = 5, edge.arrow.size = 0.5, vertex.label.cex = 0,
     vertex.color = "lightblue", edge.color = "gray",
     edge.width = E(g.weighted)$normalized_performance, vertex.label = NA, 
     edge.label = round(E(g.weighted)$weight, digits = 2), edge.label.cex = 0.7)

# Set vertex colors
V(g.weighted)$color <- ifelse(V(g.weighted)$name %in% df.football.transfer$dealing_club, "red", "blue")

# Plot the directed graph with red nodes for dealing_club and blue nodes for club
plot(g.weighted, vertex.size = 5, edge.arrow.size = 0.5, vertex.label.cex = 0,
     edge.color = "gray", vertex.label = NA, vertex.color = V(g.weighted)$color,
     edge.label = round(E(g.weighted)$weight, digits = 2), edge.label.cex = 0.7)

# Create a data frame to print out the weights of the edges
edge.list <- get.edgelist(g.weighted, names = TRUE)
weights <- get.edge.attribute(g.weighted, "weight")
weights.df <- data.frame(from = V(g.weighted)[edge.list[, 1]]$name,
                         to = V(g.weighted)[edge.list[, 2]]$name,
                         weight = weights)

# Print out the weights in a dataframe
weights.df

```

```{r }
# Bipartite sollte klappen da man 2 Kategorien hat mit nur verbindungen zwischen den Gruppen
# Bei uns aufgrund von vertex name not found nicht mÃ¶glich
# create a directed bipartite graph
#g.directed.bipartite <- graph_from_data_frame(
#  df.football.transfer[, c("dealing_club", "club")], directed = TRUE, 
#  vertices = unique(c(df.football.transfer$dealing_club, 
#                      df.football.transfer$club)))
#V(g.directed.bipartite)$color <- ifelse(V(g.directed.bipartite)$name %in% 
#                                          df.football.transfer$dealing_club,
#                                        "red", "blue")


# Create the bipartite graph
#g.directed.bipartite <- graph_from_data_frame(df.football.transfer, directed = TRUE, 
#                               vertices = c("dealing_club", "clubs", make_unique = TRUE))

# Plot the graph
#plot(g.directed.bipartite, vertex.size=3, edge.arrow.size=0.5, vertex.label=NA,
#     layout=layout_with_dh(g.directed.bipartite))
```


```{r }
# Backup

# create a directed graph
#g.all <- graph_from_data_frame(df.football.transfer[, c("dealing_club", "club")], directed = TRUE)

# add node attributes
#V(g.all)$name <- unique(c(df.football.transfer$dealing_club, df.football.transfer$club))
#V(g.all)$type <- ifelse(V(g.all)$name %in% df.football.transfer$club, "club", "dealing_club")

# add edge attributes
#E(g.all)$player <- df.football.transfer$name
#E(g.all)$season <- df.football.transfer$season

# plot the graph
#plot(g.all, vertex.color = V(g.all)$type, vertex.size = 20, vertex.label.cex = 0.8, edge.arrow.size = 0.5)

```

```{r }
# Specify used graph
g <- g.directed

# Create graph with just connected clubs
g <- induced.subgraph(g, which(degree(g) > 0))

# Remove loops from the graph --> Huge impact speak with flo
g <- simplify(g, remove.loops = TRUE)
```

```{r }
# Assuming your directed graph is stored in an object called 'g'

# Calculate in-degree and out-degree centrality measures
in.degree <- data.frame(vertex = V(g)$name, in.degree = degree(g, mode = "in"))
out.degree <- data.frame(vertex = V(g)$name, out.degree = degree(g, mode = "out"))

# Find the top 5 clubs with the highest in-degree and out-degree centrality measures
top.indegree <- in.degree[order(in.degree$in.degree, decreasing = TRUE), ][1:5, ]
top.outdegree <- out.degree[order(out.degree$out.degree, decreasing = TRUE), ][1:5, ]

# Print the top in-degree and out-degree clubs separately
cat("Top 5 clubs with highest in-degree centrality:\n")
print(top.indegree)

cat("\n\nTop 5 clubs with highest out-degree centrality:\n")
print(top.outdegree)
```


```{r }
# Neighbors of the graph

# Set the chosen club
chosen.club <- "Bayern Munich"

# Get the neighbors of the chosen club
club.neighbors <- neighbors(g, chosen.club)

# Create a subgraph consisting of the chosen club and its neighbors
all.vertices.neighbors <- c(V(g)[club.neighbors], V(g)[chosen.club])
g.club.neighbors <- induced_subgraph(g, all.vertices.neighbors)

# Plot the subgraph with the chosen club in red and its neighbors in blue:
plot(g.club.neighbors, vertex.color = ifelse(V(g.club.neighbors)$name == chosen.club, "red", "blue"), 
     vertex.size = 5)

# Get the degree (number of transfers) for each neighbor
neighbor.degrees <- degree(g, club.neighbors, mode = "in")

# Sort the neighbors based on their degree in descending order
sorted.neighbors <- sort(neighbor.degrees, decreasing = TRUE, index.return = TRUE)

# Select the top 5 neighbors based on their degree
top.neighbors <- club.neighbors[sorted.neighbors$ix[1:5]]

cat("\n\nTop neighbors of ", chosen.club, "with highest degree centrality:\n")
print(top.neighbors)

cat("\n\ Neighbors of ", chosen.club, "\n")
print(club.neighbors)

```

```{r }
# Neighbors based on weighted graph and normalized_performance index

# Specify used graph
g <- g.weighted

# Create graph with just connected clubs
g <- induced.subgraph(g, which(degree(g) > 0))

# Remove loops from the graph --> Huge impact speak with flo
g <- simplify(g, remove.loops = TRUE)

# Set the chosen club
chosen.club <- "Borussia Dortmund"

# Get all incoming edges to the chosen club
incoming.edges <- E(g)[.to(chosen.club)]

# Add a weight column to the incoming edges
weights <- get.edge.attribute(g, "weight", index = E(g))
incoming.edges$weight <- weights[incoming.edges]

# Sort the incoming edges based on their weights
#sorted.edges <- incoming.edges[order(-incoming.edges$weight), ]

# Create a subgraph consisting of the chosen club and its top 5 neighbors
all.vertices.neighbors <- c(V(g)[top.neighbors], V(g)[chosen.club])
g.club.neighbors <- induced_subgraph(g, all.vertices.neighbors)

# Plot the subgraph with the chosen club in red as focal node and neighbors blue
plot(g.club.neighbors, vertex.color = ifelse(V(g.club.neighbors)$name == chosen.club, "red", "blue"), 
     vertex.size = 5, edge.label = round(E(g.weighted)$weight, digits = 10))
```


```{r }
# Explorative Analyse
```

```{r }
# Number of clubs
unique.total.clubs <- NROW(unique(dt.filtered.data$club))
print(unique.total.clubs)

```


```{r }
# List and print the transfers in of chosen.club--------------------------------

# Get the names of the players who transferred to or from the chosen club
club.player <- unique(dt.filtered.data$name[dt.filtered.data$club == 
                                                      chosen.club])
print(club.player)

# Get the club names, movements, year of the players
player.clubs <- dt.filtered.data$club[dt.filtered.data$name %in% club.player]
player.movement <- dt.filtered.data$movement[dt.filtered.data$name %in% club.player]
player.year <- dt.filtered.data$season[dt.filtered.data$name %in% club.player]


# Combine the player names and club names into a data frame
player.df <- data.frame(Name = club.player, Club = player.clubs,
                        Movement_Transfer = player.movement, 
                        Year = player.year)

print(player.df)
```

```{r }
# Group by year and count the number of transfers per year
dt.filtered.data.per.year <- dt.filtered.data[, .(n_transfers = .N), 
                                       by = season][order(season)]
print(dt.filtered.data.per.year)

# Group by club and count the number of transfers
dt.filtered.data.per.club <- dt.filtered.data[, .(n_transfers = .N), 
                                       by = club][order(-n_transfers)]
print(dt.filtered.data.per.club)

# Group by club and year and count the number of transfers
dt.filtered.data.per.club.year <- dt.filtered.data[, .(n_transfers = .N), 
                                                         by = .(club, 
                                                                season)][order(
                                                                  season)]

print(dt.filtered.data.per.club.year)

```

```{r }
# Degree Distribution
# Plot the degree distribution for our g.transfers.in network and calculate 
# the statisitcs

degree.subgraph <- degree(g)
hist(degree(g), 
     main = "Degree Distribution of the original g.clubs.subgraph", 
     xlab = "Degree", ylab = "Number of clubs", col = "red", border = "white")

cat("\n Statistical summary of the original graph:\n")
mean(degree(g))
transitivity(g, type = "average")
average.path.length(g)
summary(g)
```

```{r }
# Get the unipartite projection 2 of clubs which show two clubs are connected
# to each other if they have at least one player in common-----------------------

#g.clubs.proj.2 <- bipartite.projection(g.transfers)$proj2

# Test if th graph contains movie with a degree of 0----------------------------


degrees.g <- degree(g)
#isolated.clubs <- which(g.clubs == 0)

cat("\nNumber of movies with a degree of zero in the projection 1 graph\n")
#print(isolated.clubs)

# Create and plot the subgraph with only connected movies including the summary
# ------------------------------------------------------------------------------

g.subgraph <- induced.subgraph(g, which(degree(g) > 0))

plot(g.subgraph, layout = layout_with_fr, 
     vertex.color = V(g.subgraph)$color, vertex.label = NA, 
     vertex.size = 1, margin = -0.1, edge.width = 0.01)
summary(g.subgraph)


degree.centrality <- degree(g.subgraph, mode = "all")

closeness <- closeness(g.subgraph)
betweenness <- round(betweenness(g.subgraph), 4)
eigenvector <- round(evcent(g.subgraph)$vector, 4)

# Create and print a dataframe with centrality measures-------------------------

df.centrality.measures.clubs <- data.frame(degree = degree.centrality,
                                            closeness = closeness, 
                                            betweenness = betweenness, 
                                            eigenvector = eigenvector)

print(df.centrality.measures.clubs)

```

```{r }

# Normalized centrality measures for better interpretations---------------------

normalized.degree <- round(degree(g.subgraph, normalized = TRUE), 4)
normalized.closeness <- round(closeness(g.subgraph, normalize = TRUE), 4)
normalized.betweenness <- round(betweenness(g.subgraph, 
                                            normalize = TRUE), 4)


# Degree centrality-------------------------------------------------------------

df.top.degree.centrality <- data.frame(degree = 
                                         head(sort(degree.centrality, 
                                                   decreasing = TRUE), 20), 
                                       normalized_degree = 
                                         head(sort(normalized.degree, 
                                                   decreasing = TRUE), 20))

print("Top 20 movies with highest degree centrality:\n")
print(df.top.degree.centrality)

# Closeness centrality----------------------------------------------------------

df.top.closeness <- data.frame(closeness = 
                                 head(sort(closeness, 
                                           decreasing = TRUE), 20),
                               normalized_closeness = 
                                 head(sort(normalized.closeness, 
                                           decreasing = TRUE), 20))

print("Top 20 movies with highest closeness centrality:\n")
print(df.top.closeness)

# Betweenness centrality--------------------------------------------------------

df.top.betweenness <- data.frame(betweenness = 
                                   head(sort(betweenness, 
                                             decreasing = TRUE), 20),
                                 normalized_betweenness = 
                                   head(sort(normalized.betweenness, 
                                             decreasing = TRUE), 20))
print("Top 20 movies with highest betweenness centrality:\n")
print(df.top.betweenness)

# Eigenvector centrality--------------------------------------------------------

df.top.eigenvector <- data.frame( eigenvector = 
                                    head(sort(eigenvector, 
                                              decreasing = TRUE), 20))
print("Top 20 movies with highest eigenvector centrality:\n")
print(df.top.eigenvector)
```





```{r }
# Step 3: Compute similarity to a specific club (e.g. Borussia Dortmund)
target_club <- "Borussia Dortmund"
similarity <- similarity(g, v = target_club, method = "invlogweight")

# Step 4: Filter out non-incoming edges
incoming_edges <- E(g)[.to(g) == V(g)[target_club]]

# Step 5: Calculate similarity of incoming edges and extract top edges
incoming_similarity <- similarity(incoming_edges, v = target_club, method = "invlogweight")
top_edges <- incoming_edges[incoming_similarity > threshold]

# Step 6: Extract subgraph and visualize
top_nodes <- c(target_club, names(tail(sort(incoming_similarity), n = num_nodes - 1)))
subgraph <- induced_subgraph(g, V(g)$name %in% top_nodes, eids = E(g) %in% top_edges)
plot(subgraph, edge.label = E(subgraph)$name)

# Step 7: Predict future transfers
shortest_paths <- get.shortest.paths(subgraph, to = target_club)
players <- data[as.matrix(shortest_paths), c("name", "dealing_club", "normalized_performance")]
players$similarity_index <- incoming_similarity[V(subgraph)$name %in% players$dealing_club]
recommendations <- players[!is.na(players$name),]

```

```{r }
# Step 2: Create a directed graph object
g <- graph_from_data_frame(data, directed = TRUE, 
                           edge.attr.comb = "sum",
                           vertices = c(unique(data$club), unique(data$country)))

# Step 3: Compute similarity between nodes
similarity <- similarity(g, method = "invlogweight")

# Step 4: Extract subgraph and remove edges that exist in original graph
subgraph <- delete.edges(induced_subgraph(g, V(g)$name == "Borussia Dortmund"))
new_edges <- data.frame(from = character(),
                        to = character(),
                        similarity_index = double(),
                        stringsAsFactors = FALSE)

# Step 5: Loop through all node pairs in subgraph
for (i in 1:(vcount(subgraph) - 1)) {
  for (j in (i + 1):vcount(subgraph)) {
    # Check if edge already exists in original graph
    if (!is.adjacent(g, V(subgraph)[i], V(subgraph)[j], mode = "out")) {
      # Compute similarity index between node pair
      similarity_index <- similarity[V(subgraph)[i], V(subgraph)[j]]
      # Add edge to new_edges dataframe if similarity is above threshold
      if (similarity_index > threshold) {
        new_edges <- rbind(new_edges, data.frame(from = V(subgraph)[i]$name,
                                                 to = V(subgraph)[j]$name,
                                                 similarity_index = similarity_index,
                                                 stringsAsFactors = FALSE))
      }
    }
  }
}

# Step 6: Visualize the new edges
new_graph <- add_edges(subgraph, cbind(new_edges$from, new_edges$to))
plot(new_graph, edge.label = new_edges$similarity_index, edge.label.cex = 0.8)

# Step 7: Generate recommendations
recommendations <- data.frame(to = character(), similarity_index = double(),
                               stringsAsFactors = FALSE)
for (i in 1:nrow(new_edges)) {
  # Find shortest path from source node to destination node
  shortest_paths <- get.shortest.paths(g, from = new_edges$from[i], to = "Borussia Dortmund")
  # Extract player name from shortest path
  player_name <- data[as.matrix(shortest_paths), "name"]
  # Add recommendation to dataframe
  recommendations <- rbind(recommendations, data.frame(to = new_edges$to[i],
                                                       similarity_index = new_edges$similarity_index[i],
                                                       player_name = player_name,
                                                       stringsAsFactors = FALSE))
}

# Step 8: Print recommendations
recommendations <- recommendations[order(-recommendations$similarity_index), ]
head(recommendations)
```

```{r }

```
```{r }
target.club <- "Borussia Dortmund"

# Step 1: Calculate Adamic-Adar score for each potential transfer target

#df.football.transfer$adamic_adar <- similarity(g, v=target.club, vmode="in", method="invlogweight", #vids=df.football.transfer$dealing_club)

#df.football.transfer$adamic_adar <- similarity(g, to=target.club, mode="in", method="invlogweight", #vids=df.football.transfer$dealing_club)

# Create directed graph with receiving club as the target node and sending club as the source node
g <- graph_from_data_frame(df.football.transfer[, c("dealing_club", "club")], directed = TRUE)

# Find vertex ID of target club
target.club_id <- V(g)$name[V(g)$name == target.club]

# Calculate Adamic-Adar score using the incoming edges to the target club
adamic_adar_scores <- sapply(target.club_id, function(x) {
  incoming_edges <- incident(g, x, mode = "in")
  similarity(g, v = incoming_edges$from, method = "invlogweight")
})

# Assign Adamic-Adar score to each potential transfer target
df.football.transfer$adamic_adar <- adamic_adar_scores[df.football.transfer$club]

# Subset df.football.transfer to potential transfer targets of target club(s)
potential_targets <- df.football.transfer[df.football.transfer$club %in% target.club, c("dealing_club", "name", "adamic_adar")]

# Print potential targets dataframe
print(potential_targets)




# Convert dealing_club and club columns to factors
df.football.transfer$dealing_club <- as.factor(df.football.transfer$dealing_club)
df.football.transfer$club <- as.factor(df.football.transfer$club)

# Create directed graph with receiving club as the target node and sending club as the source node
g <- graph_from_data_frame(df.football.transfer[, c("dealing_club", "club")], directed = TRUE)

# Find vertex ID of target club
target.club_id <- V(g)$name[V(g)$name == target.club]

# Select edges that go from dealing_club to target club
selected_edges <- E(g)[.from(g) %in% df.football.transfer$dealing_club & .to(g) %in% target.club_id]

# Create a new graph with only the selected edges
g_selected <- induced_subgraph(g, selected_edges)

# Calculate Adamic-Adar score using the selected edges
df.football.transfer$adamic_adar <- similarity(g_selected, method = "invlogweight", vids=df.football.transfer$dealing_club)

# Step 2: Group dataframe by dealing country and club, and calculate average Adamic-Adar score and number of potential transfer targets for each group
df.football.transfer_grouped <- aggregate(cbind(adamic_adar, name) ~ dealing_country + dealing_club, data=df.football.transfer, FUN=function(x) c(mean(x), length(x)))

# Calculate normalized performance for each potential transfer target
df.football.transfer_grouped$normalized_performance <- sapply(df.football.transfer_grouped$adamic_adar, function(x) x/max(df.football.transfer_grouped$adamic_adar))

# Step 3: Visualize the network graph and potential transfer targets
# First, convert dataframe to graph object
g.transfer <- graph_from_data_frame(df.football.transfer[,c("dealing_club", "club", "adamic_adar")], directed=TRUE)

# Set node colors and sizes based on normalized performance and Adamic-Adar score
V(g.transfer)$color <- heat.colors(10)[cut(df.football.transfer_grouped$normalized_performance, breaks=10)]
V(g.transfer)$size <- df.football.transfer_grouped$adamic_adar * 10

# Plot the graph using igraph
plot(g.transfer, layout=layout.reingold.tilford(g.transfer), vertex.label=NA, edge.width=E(g.transfer)$weight/5, edge.arrow.size=0.5)

# Add labels for potential transfer targets
V(g.transfer)$label <- NA
V(g.transfer)$label[df.football.transfer_grouped$name != ""] <- df.football.transfer_grouped$name[df.football.transfer_grouped$name != ""]

# Highlight Borussia Dortmund node
V(g.transfer)$color[V(g.transfer)$name=="Borussia Dortmund"] <- "red"
V(g.transfer)$size[V(g.transfer)$name=="Borussia Dortmund"] <- 20

# Save the plot as a PNG file
png("transfer_network.png", width=1200, height=800)
plot(g.transfer, layout=layout.reingold.tilford(g.transfer), vertex.label=NA, edge.width=E(g.transfer)$weight/5, edge.arrow.size=0.5)
dev.off()
```
```{r }

# Prediction by Flo
# Choose club ------------------------------------------------------------------
club.select <- "Bayern Munich"

# Filter the rows to include only last five seasons ----------------------------
df.football.5yrs <- subset(df.football.transfer, season >= 2017 & season <= 2021)

# Keep only the relevant columns -----------------------------------------------
df.football.5yrs <- subset(df.football.5yrs, 
                           select = c("dealing_club", "club", "name"))

# Create directed graph --------------------------------------------------------
g.football.5yrs <- graph_from_data_frame(df.football.transfer[, 
                                                              c("dealing_club",
                                                                "club")], 
                                         directed = TRUE)

# Get predicted edges ----------------------------------------------------------
m.predicted.edges <- as.matrix(cocitation(g.football.5yrs) * 
                                 (1 - get.adjacency(g.football.5yrs)))

df.predicted.edges <- as.data.frame(which(m.predicted.edges > 0, 
                                           arr.ind = TRUE))

colnames(df.predicted.edges) <- c("dealing_club", "club")

df.predicted.edges$transfer_weight <- m.predicted.edges[m.predicted.edges > 0]

df.predicted.edges$dealing_club <- 
  rownames(m.predicted.edges)[df.predicted.edges$dealing_club]

df.predicted.edges$club <- 
  rownames(m.predicted.edges)[df.predicted.edges$club]

# Remove self-loops where dealing club and club are the same -------------------
df.predicted.edges <- subset(df.predicted.edges, dealing_club != club)

# Normalize the transfer_weight column -----------------------------------------
max.transfer.weight <- max(df.predicted.edges$transfer_weight)

df.predicted.edges$transfer_prob <- round(df.predicted.edges$transfer_weight / 
                                            max.transfer.weight, 2)

# Filter edges to only include those with selected club as target --------------
df.predicted.edges <- df.predicted.edges[df.predicted.edges$club == 
                                             club.select, ]
df.predicted.edges <- df.predicted.edges[df.predicted.edges$dealing_club != 
                                             club.select, ]

# Keep only the relevant columns -----------------------------------------------
df.predicted.edges <- subset(df.predicted.edges, 
                             select=c("dealing_club", "club", "transfer_prob"))

# Remove the index column by setting row.names to NULL -------------------------
row.names(df.predicted.edges) <- NULL

# Sort edges by transfer probability -------------------------------------------
df.predicted.edges <- df.predicted.edges[order(df.predicted.edges$transfer_prob, 
                                                 decreasing = TRUE), ]
df.top.5.pred.dealing.clubs <- df.predicted.edges[1:5, ]
rownames(df.top.5.pred.dealing.clubs) <- NULL

# Add a new column containing the importance in the list
df.top.5.pred.dealing.clubs <- df.top.5.pred.dealing.clubs %>% 
  mutate(importance = row_number())
df.top.5.pred.dealing.clubs <- 
  df.top.5.pred.dealing.clubs[c("importance", 
                                names(df.top.5.pred.dealing.clubs)
                                [-which(names(df.top.5.pred.dealing.clubs) == 
                                          "importance")])]



# Print the top 5 predicted transfers ------------------------------------------
cat("Top 5 predicted transfers for", club.select, ":\n")
print(df.top.5.pred.dealing.clubs)

```

```{r }

# Create subgraph with dealing clubs in top 5 predicted transfers
subgraph <- induced.subgraph(g.football.5yrs, df.top.5.pred.dealing.clubs$dealing_club)

# Create a vector of vertex colors for plotting
vertex.colors <- rep("blue", vcount(subgraph))
chosen.club <- V(subgraph)[name == club.select]
vertex.colors[which(V(subgraph) == chosen.club)] <- "red"

# Plot subgraph
plot(subgraph, 
     vertex.size = 10, 
     vertex.label.color = "black", 
     vertex.label.cex = 0.8, 
     vertex.color = vertex.colors, 
     vertex.frame.color = "gray", 
     edge.arrow.size = 0.5, 
     edge.color = "gray")

```

```{r }
# Create directed graph from df.top.5.pred.dealing.clubs
g.test <- graph_from_data_frame(df.top.5.pred.dealing.clubs[, 
                                                       c("dealing_club",
                                                         "club", "transfer_prob")],
                           directed = TRUE)

# Set edge weights to transfer_probability
E(g.test)$weight <- df.top.5.pred.dealing.clubs$transfer_prob
E(g.test)$weight[E(g.test)$weight <= 0] <- NA


# Set vertex colors for chosen club and dealing clubs
V(g.test)$color <- ifelse(V(g.test)$name == chosen.club, "red", "blue")

# Plot graph
plot(g.test, 
     vertex.size = 10, 
     vertex.label.color = "black", 
     vertex.label.cex = 0.8, 
     vertex.color = V(g.test)$color, 
     vertex.frame.color = "gray", 
     edge.arrow.size = 0.5, 
     edge.color = "gray", 
     edge.width = E(g.test)$weight*10,
     edge.label = round(E(g.test)$weight, digits = 2))
```
```{r }

# Create directed graph from df.top.5.pred.dealing.clubs
g.test <- graph_from_data_frame(df.top.5.pred.dealing.clubs[, 
                                                       c("dealing_club",
                                                         "club", "transfer_prob")],
                           directed = TRUE)

# Set edge weights to transfer_probability
E(g.test)$weight <- df.top.5.pred.dealing.clubs$transfer_prob
E(g.test)$weight[E(g.test)$weight <= 0] <- NA

# Set vertex colors for chosen club and dealing clubs
V(g.test)$color <- ifelse(V(g.test)$name == chosen.club, "red", "blue")

# Set edge color palette
edge.colors <- colorRampPalette(c("yellow", "red"))(100)

# Plot graph
plot(g.test, 
     vertex.size = 10, 
     vertex.label.color = "black", 
     vertex.label.cex = 0.8, 
     vertex.color = V(g.test)$color, 
     vertex.frame.color = "gray", 
     edge.arrow.size = E(g.test)$weight*5, 
     edge.width = E(g.test)$weight*25,
     edge.label = round(E(g.test)$weight, digits = 2),
     edge.color = edge.colors[cut(E(g.test)$weight, breaks = 100)])
     
```

```{r }

# Choose club
chosen.club <- "Bayern Munich"

# Filter the rows to include only last five seasons
df.football.5yrs <- subset(df.football.transfer, season >= 2017 & season <= 2021)

# Keep only the relevant columns
df.football.5yrs <- subset(df.football.5yrs, select = c("dealing_club", "club", "name"))

# Create directed graph
g.football.5yrs <- graph_from_data_frame(df.football.transfer[, c("dealing_club", "club")], directed = TRUE)

# Get predicted edges
m.predicted.edges <- as.matrix(cocitation(g.football.5yrs) * (1 - get.adjacency(g.football.5yrs)))
df.predicted.edges <- as.data.frame(which(m.predicted.edges > 0, arr.ind = TRUE))
colnames(df.predicted.edges) <- c("dealing_club", "club")
df.predicted.edges$transfer_weight <- m.predicted.edges[m.predicted.edges > 0]
df.predicted.edges$dealing_club <- rownames(m.predicted.edges)[df.predicted.edges$dealing_club]
df.predicted.edges$club <- rownames(m.predicted.edges)[df.predicted.edges$club]

# Remove self-loops where dealing club and club are the same
df.predicted.edges <- subset(df.predicted.edges, dealing_club != club)

# Normalize the transfer_weight column
max.transfer.weight <- max(df.predicted.edges$transfer_weight)
df.predicted.edges$transfer_prob <- round(df.predicted.edges$transfer_weight / max.transfer.weight, 2)

# Filter edges to only include those with selected club as target
df.predicted.edges <- df.predicted.edges[df.predicted.edges$club == chosen.club, ]
df.predicted.edges <- df.predicted.edges[df.predicted.edges$dealing_club != chosen.club, ]

# Keep only the relevant columns
df.predicted.edges <- subset(df.predicted.edges, select=c("dealing_club", "club", "transfer_prob"))

# Remove the index column by setting row.names to NULL
row.names(df.predicted.edges) <- NULL

# Sort edges by transfer probability
df.predicted.edges <- df.predicted.edges[order(df.predicted.edges$transfer_prob, decreasing = TRUE), ]

# Select the top 5 dealing clubs with potential new connections to the chosen club
df.top.5.pred.dealing.clubs <- df.predicted.edges[1:5, ]
rownames(df.top.5.pred.dealing.clubs) <- NULL

# Add a new column containing the importance in the list
df.top.5.pred.dealing.clubs <- df.top.5.pred.dealing.clubs %>% 
  mutate(importance = row_number())

# Remove existing edges
g.football.5yrs <- delete.edges(g.football.5yrs, E(g.football.5yrs))

# Create subgraph with potential connections of the dealing clubs to the chosen club
subgraph <- induced.subgraph(g.football.5yrs, c(chosen.club, df.top.5.pred.dealing.clubs$dealing_club))

# Set vertex colors for chosen club and dealing clubs
V(subgraph)$color <- ifelse(V(subgraph)$name == chosen.club, "red", "blue")

# Plot subgraph
plot(subgraph, 
     vertex.size = 10, 
     vertex.label.color = "black", 
     vertex.label.cex = 0.8, 
     vertex.color = vertex.colors, 
     vertex.frame.color = "gray", 
     edge.arrow.size = 0.5, 
     edge.color = "gray")
```

```{r }
# Choose club
chosen.club <- "Bayern Munich"

# Filter the rows to include only last five seasons
df.football.5yrs <- subset(df.football.transfer, season >= 2017 & season <= 2021)

# Keep only the relevant columns
df.football.5yrs <- subset(df.football.5yrs, 
                           select = c("dealing_club", "club", "name"))

# Create directed graph
g.football.5yrs <- graph_from_data_frame(df.football.transfer[, 
                                                              c("dealing_club",
                                                                "club")], 
                                         directed = TRUE)

# Get predicted edges
m.predicted.edges <- as.matrix(cocitation(g.football.5yrs) * 
                                 (1 - get.adjacency(g.football.5yrs)))

df.predicted.edges <- as.data.frame(which(m.predicted.edges > 0, 
                                           arr.ind = TRUE))

colnames(df.predicted.edges) <- c("dealing_club", "club")

df.predicted.edges$transfer_weight <- m.predicted.edges[m.predicted.edges > 0]

df.predicted.edges$dealing_club <- 
  rownames(m.predicted.edges)[df.predicted.edges$dealing_club]

df.predicted.edges$club <- 
  rownames(m.predicted.edges)[df.predicted.edges$club]

# Remove self-loops where dealing club and club are the same
df.predicted.edges <- subset(df.predicted.edges, dealing_club != club)

# Normalize the transfer_weight column
max.transfer.weight <- max(df.predicted.edges$transfer_weight)

df.predicted.edges$transfer_prob <- round(df.predicted.edges$transfer_weight / 
                                            max.transfer.weight, 2)

# Filter edges to only include those with selected club as target
df.predicted.edges <- df.predicted.edges[df.predicted.edges$club == 
                                             chosen.club, ]
df.predicted.edges <- df.predicted.edges[df.predicted.edges$dealing_club != 
                                             chosen.club, ]

# Keep only the relevant columns
df.predicted.edges <- subset(df.predicted.edges, 
                             select=c("dealing_club", "club", "transfer_prob"))

# Remove the index column by setting row.names to NULL
row.names(df.predicted.edges) <- NULL

# Sort edges by transfer probability
df.predicted.edges <- df.predicted.edges[order(df.predicted.edges$transfer_prob, 
                                                 decreasing = TRUE), ]
df.top.5.pred.dealing.clubs <- df.predicted.edges[1:5, ]
rownames(df.top.5.pred.dealing.clubs) <- NULL

# Add a new column containing the importance in the list
df.top.5.pred.dealing.clubs <- df.top.5.pred.dealing.clubs %>% 
  mutate(importance = row_number())
df.top.5.pred.dealing.clubs <- 
  df.top.5.pred.dealing.clubs[c("importance", 
                                names(df.top.5.pred.dealing.clubs)
                                [-which(names(df.top.5.pred.dealing.clubs) == 
                                          "importance")])]

# Print the top 5 predicted transfers
cat("Top 5 predicted transfers for", chosen.club, ":\n")
print(df.top.5.pred.dealing.clubs)

# Remove existing edges
g.football.5yrs <- delete.edges(g.football.5yrs, E(g.football.5yrs))

# Add new edges for potential transfers
for (dc in df.top.5.pred.dealing.clubs$dealing_club) {
  # Check if the edge doesn't already exist
  if (!dc %--% chosen.club %in% E(g.football.5yrs)) {
    # Add the new edge with the predicted transfer probability as the weight
    g.football.5yrs <- add_edges(g.football.5yrs, c(dc, chosen.club),
                                weight = df.top.5.pred.dealing.clubs[df.top.5.pred.dealing.clubs$dealing_club == dc, "transfer_prob"],
                                edge.names = paste(dc, chosen.club, sep = "-"))
  }
}


# Create subgraph with potential connections of the dealing clubs to the chosen club
subgraph <- induced.subgraph(g.football.5yrs, c(chosen.club, df.top.5.pred.dealing.clubs$dealing_club))


# Set vertex color and size for chosen club and dealing clubs
V(subgraph)$color <- ifelse(V(subgraph)$name == chosen.club, "red", "blue")
V(subgraph)$size <- ifelse(V(subgraph)$name == chosen.club, 15, 10)

# Plot subgraph
plot(subgraph, 
     vertex.label.color = "black", 
     vertex.label.cex = 0.8, 
     vertex.color = V(subgraph)$color, 
     vertex.frame.color = "gray", 
     edge.arrow.size = 0.5, 
     edge.color = "gray", 
     edge.width = E(subgraph)$weight*10, 
     layout = layout_with_kk(subgraph))


```